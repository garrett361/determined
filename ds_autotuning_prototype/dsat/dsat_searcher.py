import copy
import logging
import pathlib
import shutil
import uuid

import determined as det
from determined import searcher
from dsat import constants
from ruamel import yaml


class DSATSearchMethod(searcher.SearchMethod):
    def __init__(self, hparams) -> None:
        self.hparams = hparams

    ############################################################################
    # Invoked only once, when starting a new experiment. Creates initial list
    # of operations.
    # In this example, we create and submit operations for first N trials, such that:
    #   1) each trial is assigned a unique request_id and every operation
    #      contains request_id of a trial it refers to;
    #   2) each trial is initialized with two operations:
    #      -> "Create" operation that takes in trial's request_id and hyperparameters;
    #         in this example hyperparamters are generated by user-defined method
    #         search_space(),
    #      -> "ValidateAfter" operation that takes in trial's request_id and number of
    #         units (batches or epochs) that the model is trained for before validation;
    #         units selection is made in the custom_config.yaml.
    #
    # Note: the order in which trials are created is not guaranteed.
    def initial_operations(self, _: searcher.SearcherState) -> List[searcher.Operation]:
        create = searcher.Create(
            request_id=uuid.uuid4(),
            hparams=self.hparams,
            checkpoint=None,
        )

        return [create]

    def on_trial_created(
        self, _: searcher.SearcherState, request_id: uuid.UUID
    ) -> List[searcher.Operation]:
        return []

    def on_validation_completed(
        self, _: searcher.SearcherState, request_id: uuid.UUID, metric: float, train_length: int
    ) -> List[searcher.Operation]:
        return []

    def on_trial_closed(
        self, _: searcher.SearcherState, request_id: uuid.UUID
    ) -> List[searcher.Operation]:
        return []

    def on_trial_exited_early(
        self,
        _: searcher.SearcherState,
        request_id: uuid.UUID,
        exited_reason: searcher.ExitedReason,
    ) -> List[searcher.Operation]:
        return []

    def progress(self, _: searcher.SearcherState) -> float:
        return 0


def main(core_context: det.core.Context) -> None:

    config = yaml.YAML(typ="safe")
    with open("config_custom.yaml", "r") as f:
        config_dict = config.load(f)
    # Instantiate your implementation of SearchMethod
    search_method = DSATSearchMethod(copy.deepcopy(config_dict["hyperparameters"]))
    del config_dict["hyperparameters"]

    # Instantiate RemoteSearchRunner
    search_runner = searcher.RemoteSearchRunner(search_method, context=core_context)

    ########################################################################
    # Run RemoteSearchRunner
    # ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    # 1) Creates new experiment or loads state:
    #      -> if checkpoint for an experiment exists, then RemoteSearchRunner loads its own state
    #         and invokes SearchMethod.load_method_state() to restore SearchMethod state;
    #      -> otherwise, new experiment is created.
    # 2) Handles communication between the multi-trial experiment and the custom SearchMethod
    # 3) Exits when the experiment is completed.

    search_runner.run(config_dict, model_dir=".")


if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO, format=det.LOG_FORMAT)
    info = det.get_cluster_info()
    hparams = info.trial.hparams
    with det.core.init() as core_context:
        initial_profiler_results = hparams["results"]
        main(core_context)
